import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable, Subject, Subscription, catchError, count, delay, filter, from, interval, map, of, range, throwError } from 'rxjs';
import { HttpClient, HttpErrorResponse } from '@angular/common/http'
import { Product } from './product';

@Injectable({
  providedIn: 'root'
})
export class ProductService { 

  appName='my-store'

  add(a:number, b: number): number{
    return a + b;
  }

  cartCount = 0

  //The next value of the Subject will be updated
  //when user clicks on the Add To Cart button
  //The variable whose that is displayed in the badge
  //will subscribe to the subject
  cartCountSubject$ = new BehaviorSubject<number>(0)

  increment(){
    this.cartCount ++; 
    console.log(this.cartCount)
    //++ is the increment operator 
    //that will increment the value of the variable
    //by 1
    this.cartCountSubject$.next(this.cartCount)
  }

  //////////////////////////////////////////////////////////
  /////////RxJS///////////////////////////////////////

  //observable
  values$ = of(1,2,3,"hello",true,[8,4,3])

  colors=['red','blue','yellow','green']
  colors$ = from(this.colors)

  range$ = range(2,10)

  //Custom Observable
  myObservable$ = new Observable(observe => {
    observe.next(10)
    observe.next(20)
    observe.next(30)
    observe.complete()
    observe.next('observable')    
    observe.next(true)
  })

  myNumbers$ = of(1,4,63,56,46,33,87,23,90,12,78)

  //interval operator creates an observable which emits the values
  //after the specified millisecond
  myInterval$ = interval(1000)

  subscription$?: Subscription
  subscription1$?: Subscription

  mySubject$ = new Subject<number>()  

  constructor(private http: HttpClient) { 
    //in the subscribe method we will specify
    //what is to be done on individual values of the observable stream
    // this.values$.subscribe(val => console.log("Value: " + val))
    // this.colors$.subscribe(c => console.log(c))
    // this.range$.subscribe(r => console.log(r))

    //We can subscribe to observable multiple times
    // this.myObservable$.subscribe(val => console.log("1: " + val))
    // this.myObservable$.subscribe(val => console.log("2: " + val))

    //To capture the complete stage of the observable
    // this.myObservable$.subscribe({
    //   next: val => console.log(val),
    //   complete: () => console.log('Observable Completed')
    // })

    //Pipeable operator to filter the values
    //First we apply the pipeable operator on the observable
    //This pipeable operator will return a new observable with the change 
    //And then we can subscribe to this new observable
    // this.myNumbers$.pipe(filter(val => val % 2 != 0))
    //                .subscribe(val => console.log(val))

    // this.myNumbers$.pipe(map(val => val * val))
    //                .subscribe(val => console.log(val))

    //delay will delay the observable by specified milliseconds
    // this.myNumbers$.pipe(map(val => val * val),
    //                      delay(5000))
    //                .subscribe(val => console.log(val))

    // this.myNumbers$.pipe(count(val => val % 5 == 0))
    //                .subscribe(val => console.log("Count = " + val))

    // this.subscription$ = this.myInterval$.subscribe(val => console.log("1: " + val))
    // this.subscription1$ = this.myInterval$.subscribe(val => console.log("2: " + val))

    //setTimeout is a javascript function which is used
    //to perform some fixed task after specified time in millisecond
    // setTimeout(() => {
    //   this.subscription$?.unsubscribe()
    //   this.subscription1$?.unsubscribe()
    // }, 10000)
  
    // setTimeout(() => this.myInterval$.subscribe(val => console.log("3: " + val)),3000);

    this.mySubject$.next(10)
    //the value generated by subject before subscription
    //will not be available to the subscriber
    this.mySubject$.subscribe(val => console.log("A: " + val))
    this.mySubject$.next(20)
    this.mySubject$.next(30)
    this.mySubject$.subscribe(val => console.log("B: " + val))
    this.mySubject$.next(40)
    this.mySubject$.next(50)
  }

  //This function is used to get all the products from the json server
  getProducts(): Observable<Product[]>{
    return this.http.get<Product[]>("http://localhost:3000/products")
                    .pipe(catchError(this.handleError))
  }

  //This function is used to get single/individual product from the json server
  getProductById(id: number): Observable<Product>{
    return this.http.get<Product>("http://localhost:3000/products/"+id)
                    .pipe(catchError(this.handleError))
  }

  //handleError method is called if there is an error in the URL 
  handleError(error: HttpErrorResponse){
    // console.log('error handler')
    return throwError(() => 'Some error occured at server')
  }
}
